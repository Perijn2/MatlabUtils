classdef SolenoidCoil < BaseCoil
    properties (SetAccess = protected)
        winding_density
        core_material
        end_effects
        interlayer_capacitance
    end
    
    methods
        function obj = SolenoidCoil(params)
            obj@BaseCoil('solenoid', params);
            
           

            %obj.winding_density = getfield(params, 'density', 'single_layer');

            %obj.core_material = getfield(params, 'core', 'air');
            %obj.end_effects = getfield(params, 'end_effects', true);
            obj.updateProperties();
        end
        
        function updateProperties(obj)
            calcSelfInductance(obj);
            calcResistance(obj);
        end

        function l = calcWireLength(obj)
            l = obj.geometry.turns * 2 * pi * obj.geometry.radius;  % wire length
        end
        
        function L = calcSelfInductance(obj)
            % Wheeler's formula with corrections for finite length
            a = obj.geometry.radius;
            N = obj.geometry.turns;
            l = obj.geometry.wirediameter * N ;
            
            % Basic inductance
            L_basic = obj.mu * N^2 * pi * a^2 / l;
           
            % Calculate ratio for Nagaoka's coefficient
            alpha = l / (2*a);
            
            % Nagaoka coefficient approximation (valid for most engineering cases)
            u = 1 / alpha;  % Convert to standard form u = 2a/l
            k_N = 1 / (1 + 0.383901*u + 0.017108*u^2);
            
            % Multi-layer correction if applicable
            %if strcmp(obj.winding_density, 'multi_layer')
            %    k_ML = multiLayerCorrection(obj);
            %    L = L_basic * k_N * k_ML;
            %else
                L = L_basic * k_N;
            %end
            
            obj.inductance = L;
        end
        
        function R = calcResistance(obj, frequency)
            % DC resistance + skin effect + proximity effect
            if nargin < 2, frequency = 0; end
            
            % Calculate total wire resistance of wire with material
            % resistivity
            l_wire = calcWireLength(obj);
            rho = obj.material.resistivity;
            A_wire = pi * (obj.geometry.wirediameter / 2) ^ 2;
            
            R_dc = rho * l_wire / A_wire;
            
            if frequency > 0
                % Skin depth
                delta = sqrt(2*rho / (2*pi*frequency*obj.mu0));
                
                % Skin effect factor
                if obj.geometry.wirediameter/2 > delta
                    k_skin = (obj.geometry.wirediameter/2) / delta;
                else
                    k_skin = 1;
                end
                
                % Proximity effect (simplified)
                %k_prox = proximityFactor(obj, frequency);
                
                R = R_dc * k_skin; %* k_prox;
            else
                R = R_dc;
            end
            
            obj.resistance = R;
        end

        function C = calcParasiticCapacitance(obj)
            % Self capacitance formula of a finite solenoid. Based on the
            % formula of Medhurst, and refined by David W. Knight.
            
            epsilon0 = 8.854e-12;

            a = 8e-12; %  F/m
            b = 27e-12; % F/m

            D = obj.geometry.radius*2;
            l = obj.geometry.wirediameter * obj.geometry.turns;

            C = ((4 * epsilon0 * l) / (pi)) * (1 + a*D/l + b*(D/l)^1.5);
        end

        function [f, t] = parameterizeCurve(obj, n_points)
            % parameterizeCurve - Generate parametric curve points for a solenoid
            % This function creates 3D coordinates for a helical solenoid coil
            %
            % Inputs:
            %   obj - The object containing solenoid parameters
            %   n_points - Number of points to generate along the curve
            %
            % Outputs:
            %   curve - Nx3 matrix of [x, y, z] coordinates
            %
            % Solenoid parametric equations:
            %   x(t) = radius * cos(t)
            %   y(t) = radius * sin(t)  
            %   z(t) = (height/total_turns) * (t/(2*pi))
            %
            % Where t ranges from 0 to (2*pi * number_of_turns)
            
            % Validate inputs
            if nargin < 2 || isempty(n_points)
                n_points = 100;  % Default number of points
            end
            
            if n_points < 2
                error('Number of points must be at least 2');
            end
            
            syms a N l r rho phi f t direc

            x = r * cos(direc * t + phi);
            y = r * sin(direc * t + phi); 
            z = rho * t / (2 * sym(pi));       % Linear height progression

            f(t) = [x, y, z];

            % Get solenoid parameters from object properties
            %radius = obj.geometry.radius;        % Solenoid radius
            %turns = obj.geometry.turns;          % Number of complete turns
            %height = obj.geometry.wirediameter * turns;        % Total height of solenoid
            
            %direction = 1;  % 1 for right-handed, -1 for left-handed
          
            %start_angle = 0;            % Default: start at 0 radians
            
            % Calculate parametric parameter range
            %t_max = 2 * pi * turns;         % Total angular parameter range
            %t = linspace(0, t_max, n_points);  % Parameter values
            
            % Calculate pitch (distance between turns)
            %pitch = obj.geometry.wirediameter;
            
            % Generate parametric coordinates for cylindrical helix
            % Standard helix equations with direction control
            %x = radius * cos(direction * t + start_angle);
            %y = radius * sin(direction * t + start_angle); 
            %z = pitch * t / (2 * pi);       % Linear height progression
    
     
            %    fprintf('Generated solenoid curve:\n');
            %    fprintf('  Points: %d\n', n_points);
            %    fprintf('  Radius: %.4f m\n', radius);
            %    fprintf('  Height: %.4f m\n', height);
            %    fprintf('  Turns: %.1f\n', turns);
            %    fprintf('  Pitch: %.4f m\n', pitch);
            %    fprintf('  Total length: %.4f m\n', sqrt((2*pi*radius*turns)^2 + height^2));
            
            
        end
    end
end
