classdef (Abstract) BaseCoil < handle
    properties (SetAccess = protected)
        type
        mu0, mu     % permeability constants
        pose        % 4x4 transformation matrix
        geometry    % geometry parameters struct
        material    % material properties struct
    end

    properties
        current
        voltage
    end
    
    properties (SetAccess = protected)
        resistance  % coil resistance
        inductance  % self-inductance
        capacitance % parasitic capacitance
    end
    
    methods (Abstract)
        L = calcSelfInductance(obj)
        R = calcResistance(obj, frequency)
        C = calcParasiticCapacitance(obj)
        curve = parameterizeCurve(obj, n_points)
        %flux = calcFluxTo(obj, other_coil, current)
    end
    
    methods
        function obj = BaseCoil(type, params)
            obj.type = type;

            obj.mu0 = 4*pi*1e-7;
            obj.mu = obj.mu0 * params.mu_r;

            %obj.pose = getfield(params, 'pose', eye(4));
            obj.geometry = params.geometry;
            obj.material = getMaterialProperties(params.material);
        end
        
        function M = MutualInductance(obj1, obj2, n_points)
            if nargin < 2
                error("Expected atleast two arguments");
            end
            
            if (lower(obj1.type) == "solenoid" && lower(obj2.type) == "solenoid")
                

                
            end

            if nargin < 3
                n_points = 200;
            end
        
            % Get parametric curve points for both coils
            %r1 = obj1.parameterizeCurve(n_points);  % Nx3 array
            %r2 = obj2.parameterizeCurve(n_points);  % Mx3 array
        
            % Compute differential elements and mid-points
            %dl1 = diff(r1, 1, 1);                % (N-1)x3
            %dl2 = diff(r2, 1, 1);                % (M-1)x3
            %r1_mid = (r1(1:end-1,:) + r1(2:end,:)) / 2;
            %r2_mid = (r2(1:end-1,:) + r2(2:end,:)) / 2;
        
            % Double summation - Neumann formula
            %M = 0;
            %n1 = size(dl1, 1);
            %n2 = size(dl2, 1);
        
            %for i = 1:n1
               % for j = 1:n2
                    %R_vec = r1_mid(i, :) - r2_mid(j, :);
                    %R = norm(R_vec);
                    %if R < 1e-12
                        %R = 1e-12;
                    %end
                    %dl_dot = dot(dl1(i, :), dl2(j, :));
                    %M = M + dl_dot / R;
                %end
            %end
        
            %mu0 = 4 * pi * 1e-7;
            %M = (mu0 / (4 * pi)) * M;
        end
        

        function M = NeumannAnalytic(obj1, obj2)
            % Radius of the coils
            a = obj1.geometry.radius;
            b = obj2.geometry.radius;
            
            % assume tight winding: pitch ≈ wire diameter
            pitch1 = obj1.geometry.wirediameter;
            pitch2 = obj2.geometry.wirediameter;
            
            N1 = obj1.geometry.turns;
            N2 = obj2.geometry.turns;
            
            % Optional centers; default 0 if not present
            zc1 = 0; if isfield(obj1.geometry,'z_center'), zc1 = obj1.geometry.z_center; end
            zc2 = 0; if isfield(obj2.geometry,'z_center'), zc2 = obj2.geometry.z_center; end
            
            % ---- Per-turn axial positions (centered about zc) ----
            % indices 0..N-1 centered so mean is zc
            z1 = zc1 + ((0:N1-1) - (N1-1)/2) * pitch1;   % 1 x N1
            z2 = zc2 + ((0:N2-1) - (N2-1)/2) * pitch2;   % 1 x N2
            
            % ---- Pairwise axial separations Δz (N1 x N2) ----
            [Z1, Z2] = ndgrid(z1, z2);
            DZ = Z1 - Z2;

            % ---- Build pairwise radii matrices (constant radii here) ----
            A = a * ones(N1, N2);
            B = b * ones(N1, N2);
            
            % ---- Elliptic-Integral kernel (m = k^2) ----
            m = (4.*A.*B) ./ ((A + B).^2 + DZ.^2);       % parameter m in [0,1)
            m = max(min(m, 1 - 1e-15), 0);               % clamp for numerical safety
            [K, E] = ellipke(m);                         % MATLAB complete elliptic integrals
            k = sqrt(m);
            
            % term = ((2/k) - k)*K - (2/k)*E, with safe handling at k→0
            term = zeros(size(k));
            idx  = (k > 0);
            term(idx) = ((2./k(idx)) - k(idx)).*K(idx) - (2./k(idx)).*E(idx);
            % (for k==0, contribution is 0)
            
            % ---- Sum all loop–loop contributions ----
            mu0 = 4*pi*1e-7;
            mu_r = 1.0;
            
            M_matrix = mu0*mu_r .* sqrt(A.*B) .* term;   % N1 x N2 of H
            M = sum(M_matrix, 'all'); 
        end
    end
end